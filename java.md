## 자바
<details>
  <summary>객체지향</summary>
  <br>
  <div markdown="1">
 
  **객체지향이란**  
    
  현실 세계를 프로그래밍으로 옮겨와 현실의 사물이나 개념을 상태와 행위를 가진 객체로 만들고, 이 객체들의 상호작용으로 로직을 구성하는 프로그램 방법이다.  
    
  ---  
  **객체지향의 특징**  
      
  객체지향의 대표적인 특징으로는 캡슐화, 추상화, 상속, 다형성이 있다.  
    
  **캡슐화** : 코드 재사용과 정보 은닉을 위한 특징으로 속성과 기능들을 클래스라는 캡슐에 넣는 것이라고 볼 수 있다.  
  캡슐화 이후에는 접근제어자를 통해 외부에서의 접근을 제어하여 정보를 은닉한다.  
      
  **추상화** : 객체의 공통된 속성들 중 필요한 부분을 하나의 집합으로 만드는 것이다.  
  현실의 객체를 매우 복잡하기 때문에 추상화를 통해 복잡도를 낮추고 필요한 속성들만 추출하여 사용한다.  
      
  **상속** : 자식 클래스가 부모 클래스의 속성과 기능들을 물려 받는 것을 말한다.  
      
  **다형성** : 하나의 타입 변수로 여러 타입의 객체를 참조할 수 있는 것을 말한다.  
  부모 클래스 타입의 참조 변수로 자식 클래스의 인스턴스를 참조하는 경우를 예로 들 수 있다.  
  오버로딩과 오버라이딩을 통해 하나의 함수로 여러 동작을 수행할 수 있는 것도 다형성의 한 종류이다.  
      
  ---  
      
  **객체지향 설계원칙**  
      
  객체지향 설계 원칙에는 SOLID 라 불리는 5가지 원칙이 존재한다.  
      
  **단일책임원칙(SRP)** : 하나의 클래스는 하나의 책임만 가져야 한다. (응집도는 높이고 결합도는 낮춘다.)  
  **개방폐쇄원칙(OCP)** : 확장에는 열려있고 변경에는 닫혀 있어야한다.  
  **리스코프치환원칙(LSP)** : 자식 클래스의 인스턴스는 부모 클래스의 인스터스를 완전히 대체할 수 있어야 한다. 자식은 부모의 모든 것을 물려 받아야 한다는 것을 뜻한다.  
  **인터페이스분리원칙(ISP)** : 사용하지 않는 인터페이스에 의존해서는 안된다. 각각의 기능 별로 인터페이스는 독립적으로 구현되어야 한다. 각각의 인터페이스는 서로 영향을 주면 안된다.  
  **의존역전원칙(DIP)** : 구체화보다 추상화에 의존해야 한다. 변경이 쉬운 클래스보다 변경이 어려운 인터페이스에 의존해야 한다는 의미이다.  
      
  ---  
      
  **객체지향의 장점**  
      
  1. 코드 재사용이 높다.  
  2. 유지보수가 쉽다.  
  3. 대규모 프로젝트에 적합하다.  
      
  -> 객체를 부품처럼 사용할 수 있기 때문에 코드의 재사용이 높다. 또한 절차지향에 비해 코드 수정이 편리하기 때문에 유지보수가 쉽다.  
  또 클래스 단위로 나눠서 개발할 수 있기 때문에 대규모 프로젝트에 적합하다.  
      
  ---  
      
  **객체지향의 단점**  
      
  1.절차지향에 비해 속도가 느리다.  
  2.설계 단계에서 많은 시간이 걸린다.  
      
  ---  
      
  
  </div>
</details>

<details>
  <summary>클래스 / 인스턴스란</summary>
  <br>
  <div markdown="1">
 
  **클래스** : 추상화를 거쳐 공통된 속성과 행위를 변수와 메소드로 표현한 것으로 객체를 만들기 위한 틀이다.  
      
  **인스턴스** : 클래스에서 정의한 것을 토대로 메모리에 할당된 것이다.  
      
    
  </div>
</details>

<details>
  <summary>자바</summary>
  <br>
  <div markdown="1">
 
  **자바의 특징**  
      
  1.객체지향 언어이다.  
  2.운영체제에 독립적이다.  
  3.자동으로 메모리 관리가 된다.  
  4.멀티스레드를 지원한다.  
  5.동적로딩을 지원한다.  
    
  -> 자바는 대표적인 객체지향 언어이다. 객체지향의 특징인 캡슐화, 추상화, 상속, 다형성 등이 잘 적용되었기 때문이다.  
  또한 자바는 JVM 위에서 실행되기 때문에 운영체제에 종속되지 않는다. 메모리 또한 별도의 관리를 하지 않아도 JVM의 GC 로 인해 자동으로 관리된다.  
  일반적으로 절차지향 언어들은 스레드를 운영체제의 지원을 통해 구현하는데 자바는 언어적인 측면에서 멀티스레드를 지원한다.  
  자바는 애플리케이션 실행 시 모든 객체가 생성되지 않고, 객체가 필요한 시점에 클래스를 동적로딩하여 생성한다.  
      
  ---  
      
  **동적로딩의 특징**  
      
  일부 클래스 변경 시 전체를 다시 컴파일하지 않아도된다.  
  하지만 정적 컴파일에 비해 성능이 떨어질 수 있다. 자바는 이를 보완하기 위해 static 키워드를 지원한다.  
      
  ---  
      
  **자바의 메모리 구조**  
      
  **1.메소드 영역**  
      
  JVM 이 시작될 때 생성되는 영역으로 바이트코드를 저장한다. 런타임 상수 풀이 위치한다.    
      
  **2.스택 영역**  
      
  지역 변수, 메소드 정보 등이 올라가는 LIFO 방식의 메모리 영역이다.  
  기본형 변수는 스택에 값을 저장하지만 참조형 변수는 주소를 저장한다.  
      
  **3.힙 영역**  
      
  객체를 저장하는 영역이다. new 연산자로 동적할당 된 객체들과 배열이 저장된다.  
  GC 에 의해 메모리가 관리되는 영역이다.  
  힙 영역은 효율적인 GC 수행을 위해 크게 3가지 영역, young, old, permanent 영역으로 나뉜다.  
      
  ---  
      
  **자바의 컴파일 과정**  
      
  1.자바 소스를 자바 컴파일러를 통해 컴파일한다.  
  2.컴파일 결과로 자바 바이트 코드인 .class 파일이 생성된다.  
  3.클래스로더를 통해 해당 .class 파일은 JVM 메모리 영역으로 로딩된다.  
  4.실행 엔진을 통해 명령어 단위로 실행한다.  
      
  ---  
      
  **기본형과 참조형**  
      
  **기본형**  
      
  기본형은 논리형, 문자형, 정수형, 실수형으로 나뉜다. 객체가 아니기 때문에 null 값을 가질 수 없으며 제네릭에 사용될 수 없다.  
  기본형을 객체로 사용하기 위해서는 래퍼클래스를 사용해야한다.  
  래퍼클래스를 통해 기본형을 객체로 바꾸는 것을 박싱이라 한다.  
      
  boolean - 1 바이트  
  char - 2 바이트  
  short - 2 바이트  
  int - 4 바이트  
  long - 8 바이트  
  float - 4 바이트  
  double - 8 바이트
  
  **참조형**  
      
  자바에서는 기본형을 제외한 나머지는 모든 참조형이다.  
  Obejct 클래스를 상속하는 모든 클래스이며, 클래스 타입, 인퍼페이스 타입, 배열 타입, 열거 타입 등이 존재한다.  
  null 값을 가질 수 있으며 제네릭에 사용될 수 있다.  
    
  ---  
      
  ** ==(동등연산자) 와 eqauls() 메소드**  
      
  **==(동등연산자)**  
      
  주소를 비교한다.  
      
  **equals()**  
      
  값을 비교한다.  
      
  **Stirng**  
      
  리터럴로 생성한 문자열의 경우는 문자열 상수 풀에 저장되기 때문에 값이 같은 경우 같은 주소를 갖게 된다.  
  그렇기 때문에 동등연산자와 eqauls() 의 결과가 같다.  
  하지만 new 로 생성한 문자열의 경우는 별도의 주소를 갖기 때문에 동등연산자로 비교시 값이 같더라도 false 를 반환한다.  
      
  ---  
      
  **boxing / unboxing**  
      
  **boxing** : 기본형을 래퍼클래스를 통해 참조형으로 변환하는 것이다.  
  **unboxing** : 래퍼클래스를 기본형으로 변환하는 것이다.  
    
  jdk 1.5 부터는 컴파일러가 이를 자동으로 수행해주는데 이를 오토박싱이라 한다.  
      
  ---  
      
  **String, StringBuffer, StringBuilder**  
      
  **String**  
      
  길이가 고정적이다. 문자열 연산 시 새로운 문자열을 생성한다.  
  연산이 많은 경우 비효율적이다.  
      
  **StringBuffer**  
      
  길이가 가변적이다. 동기화를 지원한다.  
      
  **StringBuilder**  
      
  길이가 가변적이다. 동기화를 지원하지 않는다.  
      
  -> 문자열 연산이 적은 경우는 String, 문자열 연산이 많고 멀티스레드인 경우에는 StringBuffer, 싱글스레드인 경우는 StringBuilder 를 사용하는 것이 효율적이다.  
      
  ---  
      
  **캐스팅(형변환)**  
      
  **묵시적 형변환**  
      
  변환할 타입을 생략하고 형변환하는 것을 묵시적 형변환이라 한다.  
  업캐스팅이 이에 해당한다.  
  업캐스팅의 경우 자식은 부모의 모든 속성과 기능을 이미 포함하고 있기 떄문에 자동으로 캐스팅이 된다.  
      
  **명시적 형변환**  
      
  변환 타입을 지정하여 형변환하는 것을 명시적 형변환이라 한다.  
  다운캐스팅이 이에 해당한다.  
      
  ---  
      
  *Error / Exception**  
      
  **Error(에러)**  
      
  에러는 시스템 수준에서 발생하는 복구할 수 없는 심각한 오류이다.  
  메모리 부족이나 스택오버플로우 등이 이에 해당한다.  
  에러는 비정상적으로 프로세스를 종료시킬 수 있다.  
    
  **Exception(예외)**  
      
  예외는 처리가 가능한 비교적 덜 심각한 오류이다.  
  개발자가 별도의 처리를 통해 프로세스 종료를 막을 수 있으며 흐름을 제어할 수 있다.  
    
  **예외의 종류**  
      
  **1.Checkd Exception**  
      
  RuntimeException 을 제외한 모든 예외가 이에 해당한다.  
  반드시 처리되어야 하는 예외이며 예외를 처리하지 않았을 경우 컴파일이 되지 않는다.  
  IOException, SQLException 등 주로 자바 프로그램이 외부와 통신하는 경우에 자주 나타난다.  
      
  **2.UnChecked Exception**  
      
  RuntimeException 하위의 모든 예외들이 이에 해당한다.  
  컴파일 시에 체크되지 않으며 런타임 시에 발생한다.  
    
    
  -> 자바에서는 에러와 예외 모두 객체로 취급하여 다룬다. 에러와 예외 모두 Throwable 클래스를 상속한다.  
      
  ---  
      
  **Collection Framework**  
      
  데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 집합이다.  
  List, Set, Map 인터페이스 등이 있다.  
    
  **List**  
      
  순서가 있으며 중복을 허용한다.  
  연속적으로 저장되기 때문에 인덱스를 사용할 수 있다.  
  구현체로는 ArrayList, Vector, LinkedList, Stack 등이 있다.  
      
  **Vector vs ArrayList**  
      
  Vector 와 ArrayList 는 기능적으로 거의 동일하다.  
  하지만 Vector 는 동기화를 지원하는데 싱글스레드에서도 동기화를 작업을 수행하여 성능이 떨어진다.  
  그래서 ArrayList 를 더 많이 사용한다.  
      
  **Set**  
      
  순서가 없으며 중복을 허용하지 않는다.  
  구현체로는 HashSet 이 있으며 순서를 유지할 필요가 있는 경우 LinkedHashSet 를 사용할 수 있다.  
      
  **Map**  
      
  순서가 없으며 키에 대해서는 중복을 허용하지 않는다.  
  key-value 쌍으로 이루어져 있다.  
  구현체로는 HashMap, TreeMap 등이 있으며 TreeMap 은 저장과 동시에 정렬을 수행한다.  
      
  ---  
      
  **Annotation**  
      
  주석처럼 코드에 달아 특별한 의미를 부여하거나 기능을 주입할 수 있게해주는 문법이다.  
  내장어노테이션, 메타어노테이션, 커스텀어노테이션 으로 나뉜다.  
  내장어노테이션은 기본적으로 제공되는 어노테이션들이다. 대표적으로 @Override 가 있다.  
  메타어노테이션은 어노테이션에 대한 정보를 표현하는 어노테이션이다. @Service 는 @Component 의 메타어노테이션이다.  
  @RestController 의 경우 @Controller 와 @ResponseBody 의 결합으로 구성되어 있다.  
  커스텀어노테이션은 개발자가 직접 만든 어노테이션이다.  
      
  ---  
      
  **static**  
      
  자바의 경우 동적로딩을 지원하는데 이를 보완하는 키워드이다.  
  정적로딩을 지원하는 키워드로 컴파일 시에 static 이 선언된 변수를 메모리에 할당한다.  
      
  ---  
      
  **final**  
      
  자바에서 제공하는 키워드로 클래스, 메소드, 변수에 따라 기능을 달리한다.  
  클래스에 사용하는 경우 다른 클래스가 상속을 하지 못하게 한다.  
  메소드에 사용하는 경우 하위 클래스에서 오버라이딩 하지 못하게 한다.  
  변수에 사용하는 경우 값을 다시 할당할 수 없다.  
      
  ---  
      
  **오버로딩과 오버라이딩**  
      
  둘의 공통점은 같은 이름의 함수에서 다른 동작을 수행하게 한다는 것이다.  
    
  **오버로딩** : 같은 이름의 함수를 매개변수의 타입과 개수를 달리하여 여러개로 만드는 기술이다.  
  **오버라이딩** : 상위 클래스의 메소드를 자식 클래스에서 재정의하여 사용하는 기술이다.  
      
  ---  
      
  **추상클래스와 인터페이스**  
      
  **추상클래스(abstract class)**  
      
  하나 이상의 추상메소드를 가진 클래스이다.  
  완성되지 않은 클래스이기 때문에 new 로 객체를 생성할 수 없다.  
  하위 클래스는 추상클래스의 추상메소드를 오버라이딩 해야 한다.  
      
  **인터페이스(interface)**  
      
  오직 추상메소드와 상수로만 이루어진 클래스이다.  
  new 로 객체를 생성할 수 없다.  
  다중상속이 가능하다.  
      
  -> 추상클래스와 인터페이스 모두 하위 클래스에게 추상메소드의 구현을 강제화하지만 둘의 목적은 차이가 있다.  
  추상클래스는 확장의 중점을 두고 인터페이스는 구현 객체의 동일성을 보장하는데 중점을 둔다.  
      
  ---  
      
  **직렬화**  
      
  자바에서 입출력을 할 때에는 스트림이라는 통로를 거치는데 객체는 바이트형이 아니라서 스트림을 통해 파일에 저장하거나 네트워크로 전송할 수 없다.  
  따라서 객체를 바이트 배열로 변환하는 것이 필요한데 이를 직렬화라 한다.  
  반대로 스트림을 통해 전달 받은 직렬화된 객체를 본래의 모습으로 되돌리는 것을 역직렬화라 한다.  
      
  **제네릭**  
      
  클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법이다.  
  타입 안정성을 높일 수 있으며, 타임 검사를 줄일 수 있다.  
    
  ---  
      
  **접근제어자**  
      
  **public** : 어디서든 접근이 가능하다.  
  **protected** : 동일 패키지 혹은 상속관계의 하위 클래스에서 접근이 가능하다.  
  **default** : 동일 패키지에서만 접근 가능하다.  
  **private** : 해당 클래스에서만 접근이 가능하다.  
      
  ---  
      
  **getter / setter **  
      
  캡슐화를 위해 사용한다.  
  멤버 변수에 private 으로 접근을 막은 뒤 해당 변수에 public 으로 getter 와 setter 를 만든다.  
  변수에 대한 올바르지 않은 접근이나 입력을 사전에 처리할 수 있다.  
      
  ---  
      
  **try-with-resource**  
      
  자동으로 자원을 해제해주는 기능이다.  
  try 에서 선언된 객체가 AutoCloseable 을 구현하였다면 try 나 catch 구문이 종료된 뒤 마지막에 해당 객체의 close() 를 자동 호출해준다.  
      
  ---  
      
  **Synchronized**  
      
  동기화는 여러 개의 스레드가 하나의 자원에 동시 접근할 때 하나의 스레드만 접근하도록 하는 것이다.  
  둘 이상의 스레드가 자원에 동시 접근하는 경우 심각한 문제가 발생할 수 있다.  
      
  1.synchronized 함수를 만들어 사용한다.  
  2.synchronized 블록을 사용한다.  
      
  ---  
      
  **finally**  
      
  try-catch 구문에서 에러나 예외의 발생여부와 상관없이 실행되어야 할 코드를 작성하는 블록이다.  
      
  ---  
      
  **익명클래스**  
      
  이름 없는 클래스를 뜻한다. 인터페이스를 구현한 클래스가 일회성이거나 재사용할 필요가 없다면 클래스를 만들지 않고 익명클래스를 사용한다.  
      
  
  </div>
</details>

<details>
  <summary>JVM</summary>
  <br>
  <div markdown="1">
 
  **JVM**  
      
  JVM 은 OS 위에서 동작하는 프로세스로 자바 바이트 코드를 해당 운영체제에 맞게 번역하여 실행하는 역할을한다.  
  또한 GC 를 수행하는 주체이기도 하다. 자바는 JVM 에 의해서 운영체제에 종속되지 않으며 자동메모리 관리가 된다.  
      
  ---  
      
  
  **JVM 구성 요소**  
      
  Class Loader : 컴파일된 .class 파일을 JVM 메모리로 로드하여 링크를 통해 메모리에 배치하는 역할  
  Executuin Engine (실행엔진) : 자바 바이트 코드를 한 줄씩 번역하여 실행하는 역할  
  Garbage Collector : GC 를 수행하는 역할  
  Runtime Data Areas : JVM 이 OS 로 부터 할당받은 메모리 영역이다.  
      
  ---  
      
  **JVM 동작 흐름**  
      
  1. 프로그램이 실행되면 JVM 은 OS 로 부터 필요한 메모리를 할당 받는다.  
  2. 자바 컴파일러가 자바 코드를 바이트 코드로 변환한다.  
  3. 변환된 .class 파일을 클래스로더가 JVM 메모리 영역으로 로딩한다.  
  4. 로딩된 .class 파일을 실행엔진이 번역하여 실행한다.  
      
  ---  
      
  
  </div>
</details>

<details>
  <summary>컴파일 방식 / 인터프리터 방식 / JIT 컴파일러</summary>
  <br>
  <div markdown="1">
 
  **컴파일 방식**  
      
  컴파일 방식은 코드를 통째로 한번에 번역하는 방식이다.  
  번역 이후에는 실행파일이 생성되어 이후 실행 부터는 실행속도가 빠르다.  
  실행파일을 생성하기 때문에 플랫폼에 종속적이다.  
      
  ---  
      
  **인터프리터 방식**  
      
  인터프리터 방식은 코드를 컴파일하지 않고 실행 시에 한 줄씩 번역하는 방식이다.  
  목적파일이 없기 때문에 번역속도가 빠르지만 매 실행시마다 번역을 하기 때문에 실행속도는 다소 느리다.  
  대표적인 언어로는 자바스크립트, 파이썬 등이 있다.  
      
  ---  
      
  **JIT 컴파일러**  
      
  기존 인터프리터 방식의 단점 보완한 컴파일 방식이다.  
  실행 시점에 인터프리터 방식으로 번역을 하면서 번역된 바이트 코드를 캐싱하여 같은 함수가 호출되는 경우  
  번역을 하지 않고 캐시에서 꺼내와 사용한다.  
  JVM 과 node.js 가 JIT 컴파일 방식을 사용한다.  
      
  ---  
      
  
  </div>
</details>

<details>
  <summary>Call by Value vs Call by Reference</summary>
  <br>
  <div markdown="1">
 
  **Call by value**  
      
  인자의 값을 복사하여 처리하는 방식이다.  
  복사한 값을 사용하기 때문에 메소드 내의 처리 결과는 메소드 밖의 원본 데이터에 영향을 주지 않는다.  
  복사를 하기 때문에 메모리 사용이 늘지만 원본 데이터를 보호할 수 있다.  
      
  ---  
      
  **Call by Reference**  
      
  인자의 주소 값을 통해 직접 값에 영향을 주는 방식이다.  
  인자를 복사하지 않고 직접 참조하기 때문에 메로리 사용도 적고 속도도 빠르다.  
  하지만 원본 데이터가 훼손될 가능성이 있다.  
      
  ---  
      
  **자바는 Call by Value**  
      
  자바는 Call by Value 이다.  
  객체를 인자로 받아 객체의 프로퍼티를 수정할 수 있기에 Call by Reference 로 생각할 수 있지만,  
  자바는 인자의 주소 값을 복사하여 사용하기 때문에 프로퍼티에는 접근이 가능하지만 원본 객체 자체를 변화시키지는 못한다.  
    
  ---  
      
  
  </div>
</details>

<details>
  <summary>Garbage Collection</summary>
  <br>
  <div markdown="1">
 
  JVM 의 Garbage Collector 가 더 이상 필요없는 객체를 찾아 사용가능한 자원으로 회수하는 동작을 말한다.  
  GC 동작 시 GC 를 수행하는 스레드 이외의 스레드가 모두 멈추는 stop-the-wolde 가 발생하는데  
  이 stop-the-world 시간을 줄이기 위해 Serial GC, Parallel GC, Parallel Old GC, CMS, G1 GC 등 여러 알고리즘이 사용된다.  
      
  **GC 동작 과정**  
      
  GC 의 동작은 2가지 가설을 기반으로 작동한다.  
    
  1.대부분의 객체는 금방 접근불가능 상태가 된다.  
  2.오래된 객체가 젊은 객체를 참조하는 일은 드물다.  
      
  GC 가 일어나는 힙 영역은 2 가지 가설을 효율적으로 적용하기 위해 각각의 영역으로 나눠져 있다.  
    
  **Eden** : 새롭게 생성된 객체가 위치하는 영역이다.  
  **Survivor** : Eden 에서 최소 1번 이상의 GC 에서 살아남은 객체가 위치하는 영역이다.  
  **Young Generation** : Eden 과 Survivor 를 포함하는 영역이다. 이곳에서 일어나는 GC 를 Minor GC 라 한다.  
  **Old Generation** : Young 영역에서 살아남은 객체가 이동하는 영역이다. Old 영역이 꽉 찬 경우 Major GC 가 일어난다.  
      
  1. 객체가 새롭게 생성되면 Eden 영역에 위치한다.  
  2. Eden 영역이 가득찬 경우 minor GC 가 수행되며 살아남은 객체는 Survivor 0 로 이동한다.  
  3. 위의 과정이 반복되면서 Survivor 0 가 가득찬 경우 Survivor 0 의 객체들을 Survivor 1 으로 이동시킨다.  
  4. 이 과정을 계속 거쳐 계속해서 살아남은 객체는 old 영역으로 이동한다.  
  5. old 영역이 가득찬 경우 major GC 를 수행한다.  
      
  ---  
      
  **GC 알고리즘**  
      
  **1.Serial GC**  
      
  mark-sweep-compact 알고리즘을 사용한다.  
  적은 메모리와 CPU 개수가 적을 때 적합한 방식이다.  
    
  **mark-sweep-compact**  
  mark : GC 대상이 아닌 객체를 식별하는 과정이다.  
  sweep : 힙의 앞에서부터 mark 된 객체를 제외하고 제거하는 과정이다.  
  compact : sweep 이후 힙의 빈 공간들을 앞부분 부터 채우는 과정이다.  
      
  **2.Parallel GC(Throughput GC)**  
      
  Serail GC 와 기본적인 알고리즘은 같지만 여러개의 스레드로 처리한다.  
  메모리가 충분하고 CPU 개수가 많을 때 유리하다.  
      
  **Parallel Old GC**  
      
  Parallel GC 와 비슷하지만 sweep 대신 summary 과정을 거친다.  
  summary : GC를 수행한 영역에서 별도의 살아있는 객체를 식별한다.  
      
  **Concurrent Mark & Sweep(CMS)**  
      
  stw 시간이 가장 짧은 방법이다.  
  Concurrent Mark, Concurrent Sweep 과정에서 다른 스레드가 중단되지 않는다.  
  메모리와 CPU 를 많이 사용한다.  
      
  **G1 GC**  
      
  메모리를 바둑판 모양으로 구분하고 각 영역에 대해 GC 를 수행한다.  
  기존의 old, young 영역으로 나눈 것을 한 영역에서 처리하는 개념이다.  
  성능이 뛰어나다.  
      
  ---  
      
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

<details>
  <summary></summary>
  <br>
  <div markdown="1">
 
  
  </div>
</details>

