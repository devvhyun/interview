## 자료구조
<details>
  <summary>선형자료구조</summary>
  <div markdown="1">
    
  하나의 자료 뒤에 하나의 자료가 존재하는 것이다.  
  자료들 간의 앞 뒤 관계가 1:1의 선형관계  
  배열, 리스트, 스택, 큐 등
  </div>
</details>
<details>
  <summary>비선형자료구조</summary>
  <div markdown="1">
    
  하나의 자료 뒤에 여러개의 자료가 존재할 수 있는 것이다.  
  자료들 간의 앞 뒤관계가 1:n 또는 n:n 이다.  
  트리, 그래프 등 계층적 구조를 나타내기에 적합하다.  
  </div>
</details>
<details>
  <summary>Array</summary>
  <div markdown="1">
  
  논리적 저장 순서와 물리적 저장 순서가 일치하는 자료구조이다.  
  따라서 인덱스로 원소에 접근할 수 있다.  
  해당 원소의 인덱스를 알고 있다면 O(1) 으로 접근이 가능하다.  
  하지만 원소의 삽입 또는 삭제의 경우 shift 가 발생할 수 있기에 최악의 경우 O(N) 이 소요된다.  
  **길이가 고정적이다.**  
  기본형과 참조형 모두 저장가능하다.  
  하나의 배열에 한 가지 타입만 저장이 가능하다.  
  length 프로퍼티를 통해 배열의 길이를 알 수 있다.
  </div>
 </details>
<details>
  <summary>ArrayList</summary>
  <div markdown="1">
  
  내부적으로는 배열로 구현되어 있는 선형자료구조이다.  
  배열의 특징을 모두 갖고 있다.  
  배열과의 가장 큰 차이는 **길이가 가변적이라는 것이다.**  
  배열의 크기를 자동으로 늘려준다.  
    내부 capcity 변수를 통해 배열의 크기를 자동으로 늘려준다.  
    배열에 데이터가 추가되어 배열의 길이가 capacity 와 같아지면  
    기존 capacity 의 1.5배 크기의 배열을 만들고 기존 배열을 복사하여 옮긴다.  
  참조형만 저장 가능하다.  
  여러가지 타입의 원소를 저장할 수 있다.  
  기본형의 경우 래퍼클래스를 사용해 저장한다.  
  제네릭 사용이 가능하다.  
  size() 메소드로 길이를 알 수 있다.  
  </div>
 </details>
<details>
  <summary>Array vs ArrayList</summary>
  <div markdown="1">
  
  Array 와 ArrayList 모두 연속된 공간에 데이터를 저장하는 선형자료구조이다.  
  ArrayList 도 내부적으로는 배열로 구현되어 있다.  
  둘 다 인덱스를 사용할 수 있다.  
  접근 시에는 O(1), 검색 시에는 O(N), 추가, 삭제 시에는 O(N) 이 걸린다.  
  데이터의 변경이 적고 조회가 많은 경우 효율적인 자료구조이다.  
    
  가장 큰 차이점은 길이가 가변적인지 고정적인지이다.  
  Array 의 경우 길이가 고정적이고 ArrayList 는 가변적이다.  
  Array 는 다차원이 가능하지만 ArrayList 는 단일차원만 가능하다.  
  Array 는 기본형과 참조형 모두 저장 가능하지만, ArrayList 는 참조형만 저장 가능하다.  
  ArrayList 는 제네릭을 사용할 수 있다.  
  Array 는 length 프로퍼티를 통해 길이를 알 수 있고 ArrayList 는 size() 메소드를 통해 알 수 있다.
  </div>
 </details>
<details>
  <summary>LinkedList</summary>
  <div markdown="1">
  
  요소들간의 연결을 통해 리스트를 구현한 선형자료구조이다.  
  노드라 불리는 각 요소들은 데이터와 포인터를 가지고 있다.  
  포인터에는 연결된 노드의 주소 정보가 담겨있다.  
  원하는 위치의 앞, 뒤 노드를 알고 있는 경우 O(1) 에 삽입, 삭제가 가능하다.  
  하지만 앞,뒤 노드를 모르는 경우 순차 탐색을 거치기 때문에 O(N) 이 소요된다.  
  Array 는 Stack 영역에 할당되지만 LinkedList 는 Heap 영역에 할당된다.  
  요소가 추가, 삭제되는 런타임시에 메모리에 할당되는 동적 메모리 할당이다.  
  
  </div>
 </details>
<details>
  <summary>Array vs LinkedList</summary>
  <div markdown="1">
  
  Array 는 임의 접근을 지원한다.  
  인덱스를 통해 요소들에 접근하며 O(1) 이다.  
  LinkedList 는 순차 탐색을 통해 요소에 접근하며 O(N) 이다. 
    
  Array 는 삽입, 삭제 시 shift 가 발생하여 O(N) 이다.  
  LinkedList 는 연결된 노드의 포인터만 수정하면 되기 때문에 O(1) 이다.  
  
  Array 는 컴파일 시 메모리에 할당이 되는 정적 메모리 할당이다.  
  LinkedList 는 요소가 추가, 삭제되는 런타임에 메모리에 할당되는 동적 메모리 할당이다.  
    
  Array 는 스택 영역에 메모리가 할당되며, LinkedList 는 힙 영역에 메모리가 할당된다.
    
  데이터의 변경이 적고 조회가 많은 경우 Array, 변경이 많고 조회가 적은 경우는 LinkedList 를 사용하는 것이 효율적이다.  
  LinkedList 는 데이터와 포인터를 저장하기 때문에 포인터라는 오버헤드가 발생한다.  
  </div>
 </details>
<details>
  <summary>ArrayList vs LinkedList</summary>
  <div markdown="1">
  
  ArrayList 는 길이가 가변적이나 내부적으로는 배열로 구현되어 있기 때문에 길이 변경 시 배열의 복사가 이뤄진다.  
  LinkedLisst 는 한 개의 노드에 다른 노드에 대한 참조만 가지고 있기 때문에 공간적 제약을 받지 않는다.  
    
  요소에 대한 접근 시에는 ArrayList 는 O(1), LinkedList 는 O(N) 이다.  
  추가 시에는 ArrayList 는 여유 공간이 있는 경우 O(1) 이지만 여유 공간이 없는 경우 O(N) 이다.  
  삽입, 삭제 시에는 ArrayList 는 shift 가 발생한다. LinkedList 는 연결된 노드의 포인터만 변경하면 된다. 
    
  LinkedList 는 데이터와 포인터를 저장하기 때문에 포인터라는 오버헤드가 발생한다.  
  </div>
 </details>
 <details>
  <summary>Stack</summary>
  <div markdown="1">
    
  나중에 들어온 데이터가 먼저 나가는 **후입선출(LIFO)** 방식의 선형자료구조이다.  
  박스를 차곡차곡 쌓는 형태라 볼 수 있다.  
  삽입과 삭제가 한 방향에서만 이루어진다.  
  콜스택, 재귀, 브라우저의 뒤로가기, DFS, 안드로이드의 액티비티 등에서 사용된다. 
  
  </div>
</details>
<details>
  <summary>Queue</summary>
  <div markdown="1">
    
  먼저 들어온 데이터가 먼저 나가는 **선입선출(FIFO)** 방식의 선형자료구조이다.  
  한 줄로 늘어선 대기줄을 예로 들 수 있다.  
  front 에서만 삭제되고 rear 에서만 삽입된다.  
  큐는 인터페이스
  </div>
</details>
  
<details>
  <summary>Tree</summary>
  <div markdown="1">
    
  계층적 관계를 표현하는 비선형자료구조이다.  
  값을 가진 노드와 이를 연결하는 간선으로 이루어져있다.  
  사이클이 없는 방향그래프인 DAG 의 한 종류이다.  
      
  **Binary Tree (이진트리)**  
    
  자식 노드가 최대 두개인 노드들로 구성된 트리이다.  
    
  **트리순회방식**  
    
    - 전위순회(pre-order)  
      각 루트를 순차적으로 먼저 방문하는 방식  
      루트 -> 왼쪽자식 -> 오른쪽자식
      1 2 4 8 9 5 10 11 3 6 13 7 14  
      
    - 중위순회(in-order)  
      왼쪽 하위 트리를 방문 후 루트를 방문하는 방식  
      왼쪽자식 -> 루트 -> 오른쪽자식  
      8 4 9 2 10 5 11 1 6 13 3 14 7  
      
    - 후위순회(post-order)  
      왼쪽 하위 트리부터 모두 방문 후 루트를 방문하는 방식  
      왼쪽자식 -> 오른쪽자식 -> 루트  
      8 9 4 2 10 11 5 2 13 6 14 7 3 1  
      
    - 레벨순회(level-order)  
      1 2 3 4 5 6 7 8 9 10 11 13 14  
    
  **Complete Binary Tree(완전 이진트리)**  
      
  마지막 레벨을 제외하고 트리의 모든 레벨이 완전히 채워져 있는 트리이다.  
  마지막 레벨은 완전히 채워져 있지 않아도 되지만 왼쪽부터 채워져 있어야 한다.  
    
  ---
    
  **Full Binary Tree(정 이진트리)**  
      
  모든 노드가 0개 또는 2개의 자식 노드를 갖는 이진트리이다.  
      
  ---  
    
  **Perfect Binary Tree(포화 이진트리)**  
      
  정 이진트리이면서 완전 이진트리인 트리이다.  
  마지막 레벨을 포함하여 모든 레벨이 완전히 채워져 있다.  
      
  ---  
    
  **Binary Search Tree, BST(이진 탐색 트리)**  
      
  이진트리의 일종으로 이진 탐색과 연결리스트의 장점을 합쳐 효율적인 탐색이 가능하고  
    데이터의 삽입, 삭제가 가능한 트리이다.  
      
  이진 탐색 : 탐색이 O(logN) 이지만 삽입, 삭제가 불가능함  
  연결리스트 : 삽입, 삭제가 O(1) 이지만 탐색이 O(N) 으로 비효율적임  
      
  **특징**  
  1. 각 노드의 왼쪽 자식은 루트보다 작거나 같다.  
  2. 각 노드의 오른쪽 자식은 루트보다 크거나 같다.  
  3. 중복된 노드가 없어야 한다.  
  4. 중위순회방식으로 순회할 경우 오름차순 정렬이 된다.  
      
  ---  
    
  **Heap(힙)**  
      
  완전이진트리의 일종으로 최댓값과 최솟값을 빠르게 찾아낼 수 있는 자료구조이다.  
    
  최대힙 : 부모 노드의 키 값이 항상 자식 노드의 키 값보다 큰 힙  
  최소힙 : 부모 노드의 키 값이 항상 자식 노드의 키 값보다 작은 힙  
      
  ---  
      
  **Red Black Tree, RBT(레드-블랙 트리)**  
      
  
  이진탐색트리를 기반으로 한 트리 자료구조이다.  
  이진탐색트리는 평균적인 경우 탐색, 삽입, 제거 연산에 O(logN) 의 시간복잡도를 가진다.  
  하지만 최악의 경우(한쪽으로 치우친 이진탐색트리)에는 O(N) 의 시간복잡도를 가진다.  
  이를 보완하기 위해 트리의 균형을 잡고 최악의 경우에도 O(logN) 의 시간복잡도를 보장해주는  
  균형잡힌 트리의 일종이다.  
    
  **RBT 의 특징**  
  1. 모든 노드는 레드 혹은 블랙의 색깔을 가진다.  
  2. 루트 노드는 항상 블랙이다.  
  3. 리프 노드는 항상 블랙이다. (NIL)   
  4. 레드 노드는 연속으로 나올 수 없다.  
  5. 모든 리프노드에서 루트노드까지의 블랙노드의 갯수는 같다.  
  * 노드의 자식이 없는 경우 NIL 을 삽입한다. (더미노드)  
  * 루트 노드에서 리프 노드 까지의 최대 경로는 최소 경로의 2배 보다 작다.  
      
  **Double Red 해결법**  
    
  **Restructuring** : 삼촌 노드가 블랙인 경우에 수행한다.  
        
  1. 자신, 부모, 부모의 부모를 오름차순 정렬한다.  
  2. 가운데 노드를 부모 노드로, 나머지 노드를 자식 노드로 정한다.  
  3. 부모는 블랙, 자식들은 레드로 정한다.  
      
  **Recoloring** : 삼촌 노드가 레드인 경우에 수행한다.  
      
  1. 부모와 삼촌 노드를 블랙으로, 부모의 부모를 레드로 정한다.  
  2. 부모의 부모가 루트가 아닐 경우 Double Red 가 다시 발생할 수 있다.  
      
  </div>
</details>

  
